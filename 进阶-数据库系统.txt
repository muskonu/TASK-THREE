1.DBMS管理数据的三个层次
	1.external level=user level  某一用户能够看到与处理的数据，全局数据中的某一部分
	2.Conceptual Level=Logic level  从全局角度理解/管理的数据, 含相应的关联约束
	3.Internal Level=Physical level存储在介质上的数据，含存储路径、存储方式 、索引方式等

2.关系模型就是处理Table的，它由三个部分组成：
 描述DB各种数据的基本结构形式(Table/Relation)
 描述Table与Table之间所可能发生的各种操作(关系运算)
 描述这些操作所应遵循的约束条件(完整性约束）

3.关系模型的三个要素(详细内容在后面讲述)
 基本结构：Relation/Table
 基本操作：Relation Operator 
 完整性约束：实体完整性、参照完整性和用户自定义的完整性

4.“列”的取值范围“域(Domain）
集合中元素的个数称为域的基数(Cardinality)

5.笛卡尔积(Cartesian Product)
一组域D1 , D2 ,…, Dn的笛卡尔积为:
D1×D2×…×Dn = { (d1 , d2 , … , dn) | di∈Di , i=1,…,n }
笛卡尔积的每个元素(d1 , d2 , … , dn)称作一个n-元组（n-tuple）
 元组(d1 , d2 , … , dn)的每一个值di叫做一个分量(component)
 元组(d1 , d2 , … , dn)是从每一个域任取一个值所形成的一种组合，笛
卡尔积是所有这种可能组合的集合， 即：笛卡尔积是由n个域形成的所有
可能的n-元组的集合
 若Di的基数为mi，则笛卡尔积的基数，即元组个数为
m1*m2*…*m

6.关系(Relation)
一组域D1 , D2 ,…, Dn的笛卡尔积的子集
笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)
由于关系的不同列可能来自同一个域，为区分，需要为每一列起一个名
字，该名字即为属性名。
关系可用R(A1:D1 , A2:D2 , … , An:Dn )表示，可简记为R(A1 , A2 , … , 
An )，这种描述又被称为关系模式(Schema)或表标题(head)
 R是关系的名字, Ai 是属性, Di 是属性所对应的域, n是关系的度或目
(degree), 关系中元组的数目称为关系的基数(Cardinality)
 例如下图的关系为一3目关系，描述为
家庭(丈夫:男人，妻子:女人, 子女:儿童)或家庭(丈夫，妻子, 子女)

关系模式R(A1:D1 , A2:D2 , … , An:Dn ) 中属性向域的映象在很多DBMS
中一般直接说明为属性的类型、长度等
 例如：
Student( S# char(8), Sname char(10), Ssex char(2), 
Sage integer, D# char(2), Sclass char(6) )
再如：
Course ( C# char(3), Cname char(12), Chours integer, 
Credit float(1), T# char(3) ) 
SC( S# char(8), C# char(3), Grade float(1））

不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予
不同的属性名。
 关系模式R(A1:D1 , A2:D2 , … , An:Dn )中，Ai (i = 1,…,n)必须是不同的, 而
Di(i = 1,…,n) 可以是相同的

7.关系模式与关系
 同一关系模式下，可有很多的关系
 关系模式是关系的结构, 关系是关系模式在某一时刻的数据
 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的

8.候选码(Candidate Key)/候选键
关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉
任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。
例如：“学生(S#, Sname, Sage, Sclass)”，S#就是一个候选码，在此
关系中，任何两个元组的S#是一定不同的，而这两个元组的Sname, 
Sage, Sclass都可能相同(同名、同龄、同班)，所以S#是候选码。
再如：“选课(S#, C#, Sname, Cname, Grade)”，(S#,C#)联合起来是一
个候选码

 有时，关系中有很多组候选码，例如：
学生(S#, Sname, Sage, Sclass, Saddress)
其中属性S#是候选码，属性组(Sname, Saddress)也是候选码(同名同地
址的两个同学是不存在的)
 再如
Employee(EmpID, EmpName, Mobile)
每一雇员有唯一的EmpID, 没有两个雇员有相同的手机号Mobile, 则
EmpID是候选码，Mobile也是候选码

9.主码(Primary Key)/主键
当有多个候选码时，可以选定一个作为主码。
DBMS以主码为主要线索管理关系中的各个元组。
例如可选定属性S#作为“学生”表的主码，也可以选定属性组(Sname, 
Saddress)作为“学生”表的主码。选定EmpID为Employee的主码。

10.主属性与非主属性
包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性
如 “选课”中的S# , C#为主属性，而Sname, Cname, Grade则为非
主属性；
最简单的，候选码只包含一个属性
最极端的，所有属性构成这个关系的候选码，称为全码(All-Key)。
比如：关系“教师授课”(T#,C#)中的候选码(T#,C#)就是全码。

11.外码(Foreign Key)/外键
关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选
码相对应，则称这个属性组为R的外码或外键。
例如“合同”关系中的客户号不是候选码，但却是外码。因它与“客户”关
系中的候选码“客户号” 相对应。
两个关系通常是靠外码连接起来的。

12.实体完整性
 关系的主码中的属性值不能为空值；
 空值：不知道或无意义的值；
 意义：关系中的元组对应到现实世界相互之间可区分的一个个个
体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识
的个体，这是不容许的。

13.参照完整性
如果关系R1的外码Fk与关系R2的主
码Pk相对应，则R1中的每一个元组的
Fk值或者等于R2 中某个元组的Pk 值，
或者为空值
意义：如果关系R1的某个元组t1参照
了关系R2的某个元组t2，则t2必须存在
例如关系Student在D#上的取值有两
种可能:
空值，表示该学生尚未分到任何系中
若非空值，则必须是Dept关系中某个
元组的D#值，表示该学生不可能分到一
个不存在的系中。

14.用户自定义完整性
 用户针对具体的应用环境定义的完整性约束条件
 如S#要求是10位整数，其中前四位为年度，当前年度与他们的
差必须在4以内

15.关系代数操作：集合操作和纯关系操作

16.某些关系代数操作，如并、差、交等，需满足“并相容性”
并相容性
 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性
 定义：关系R与关系S存在相容性，当且仅当：
(1) 关系R和关系S的属性数目必须相同；
(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同
假设：
R(A1, A2, … , An) , S(B1, B2, … ,Bm)
R和S满足并相容性：n = m 并且 Domain(Ai) = Domain(Bi）

并相容性的示例
STUDENT(SID char(10), Sname char(8), Age char(3))
PROFESSOR(PID char(10), Pname char(8), Age char(3)) 
关系STUDENT与关系PROFESSOR是相容的，因为：
(1) 关系R和关系S的属性数目都是3
(2) 关系R的属性SID与关系S的属性PID的域都是char(10)
(3) 关系R的属性Sname与关系S的属性Sname的域都是char(8)
(4) 关系R的属性Age与关系S的属性Age的域都是char(3）

		集合操作

17.并(Union)
同高中数学并

18.差(Difference)
 定义：假设关系R 和关系S是并相容的，则关系R 与关系S 的差运算结果
也是一个关系，记作：R - S, 它由出现在关系R中但不出现在关系S中的元
组构成
 R - S 与 S - R 是不同的

19.广义笛卡尔积 (Cartesian Product)
 定义：关系R (<a1 , a2, …, an >) 与关系S(<b1, b2, …, bm >) 的广义笛卡尔积
(简称广义积,或 积 或笛卡尔积) 运算结果也是一个关系，记作： R x S, 它由
关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。

20.交（Intersection）
同高中数学交
交运算可以通过差运算来实现

		纯关系操作

21.选择(Select)
见PPT

22.条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先
次序，优先次序自高至低为{ 括弧；θ ；ョ ；∀  ；非 ；∧ ；∨ }

23.投影(Project)
 定义：给定一个关系R, 投影运算结果也是一个关系，记作 ΠA(R) , 它从
关系R中选出属性包含在A中的列构成。
 投影操作从给定关系中选出某些列组成新的关系, 而
选择操作是从给定关系中选出某些行组成新的关系
⭐	 如果投影后有重复元组，则应去掉

24.θ-连接(θ-Join, theta-Join）
见PPT

25.ρSC1 (SC)表更名操作，即将表SC更名为SC1，当一个表需要
和其自身进行连接运算时，通常要使用更名操作

26. 特别注意：
虽然我们在讲解θ-连接操作时，使用笛卡尔积然后再进行选择来得到θ-
连接结果。这主要是方便大家理解。但当引入连接操作后，DBMS可直接进
行连接操作，而不必先形成笛卡尔积。

27.等值连接(Equi-Join)
当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；
 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常
庞大，因此采用θ-连接/等值连接运算可大幅度降低中间结果的保存量，提
高速度

28.自然连接(Natural-Join)
自然连接是一种特殊的等值连接
要求关系R和关系S必须有相同的属性组B
(如R,S共有一个属性B1,则B是B1 , 如R, S共有一组属性B1, B2, …, Bn，则B是这些共有的所有属性)
 R, S属性相同，值必须相等才能连接，即
R.B1 = S.B1 and R.B2 = S.B2 … and R.Bn = S.Bn才能连接
 要在结果中去掉重复的属性列
(因结果中R.Bi 始终是等于S.Bi 所以可只保留一列即可）

29. 书写关系代数表达式的基本思路
 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择
与投影，只要注意条件书写正确与否即可
 如涉及多个表，则检查
 能否使用自然连接，将多个表连接起来(多数情况是这样的)
 如不能，能否使用等值或不等值连接(θ-连接)
 还不能，则使用广义笛卡尔积，注意相关条件的书写
 连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投
联”操作。

30.除(Division)
定义：关系R 和关系S的除运算结果也是一个关系，记作R ➗ S，分两部
分来定义。
先定义R➗S结果的属性应有哪些？
设属性集{C1,C2, … ,Ck } = {A1,A2, … ,An } – {B1,B2, … ,Bm }, 则有k=n–m
则R➗S结果关系是一k度(n-m度)关系，由{C1,C2, … ,Ck }属性构成

除法运算经常用于求解“查询… 全部的/所有的…”问题

31.再定义R➗S的元组怎样形成？
再设关系R (<a1, …, an>)和关系S (<b1, …, bm >), 那么RS结果关系为
元组 <c1, …, ck>的集合，元组 <c1, …, ck>满足下述条件：
它与S中每一个元组<b1, …, bm >组合形成的一个新元组都是R中的某一
个元组<a1, …, an> 。(其中，a1, …, an ,b1, …, bm, c1, …, ck分别是属性
A1 , … ,An,B1 , … ,Bm C1 , … ,Ck 的值）

32.Division示例
	见PPT

33.外连接(Outer-Join)
定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找
不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中
假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为
外连接(Outer Join)。

34. 外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)
 外连接的形式：左外连接、右外连接、全外连接
 左外连接 = 自然连接(或θ连接) + 左侧表中失配的元组
 右外连接 = 自然连接(或θ连接) + 右侧表中失配的元组
 全外连接 = 自然连接(或θ连接) + 两侧表中失配的元组

35.		关系演算
关系演算是以数理逻辑中的谓词演算为基础的
关系演算是描述关系运算的另一种思维方式
SQL语言是继承了关系代数和关系演算各自的优点所形成的
按照谓词变量的不同，可分为关系元组演算和关系域演算
 关系元组演算是以元组变量作为谓词变量的基本对象
 关系域演算是以域变量作为谓词变量的基本对象

36.关系元组演算公式的基本形式：
{ t | P(t) }
上式表示：所有使谓词 P 为真的元组 t 的集合

37.其中公式P(t)可以递归地进行构造：
见PPT

38. 运算符ョ 和∀，又称为量词，前者称“存在量词”，后者称“全称量词”
 而被 ョ 或 ∀ 限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称
量词，则该变量被称为“约束变量”，否则被称为“自由变量”。

39.{ t | P(t) }
P(t)公式，如谓词演算一样，也有一系列演算的等价性

40. 再例如 ∧ 、∨与¬ 运算之间的等价性
P1 ∧ P2  ¬ (¬ P1 ∨ ¬ P2)
n个否定的或操作的再否定，便是n个肯定的与操作
P1 ∨ P2  ¬(¬ P1 ∧ ¬ P2)
n个否定的与操作的再否定，便是n个肯定的或操作

41.元组演算的基本形式： { t | P(t) }
域演算的基本形式： { < x1 , x2 , … , xn > | P ( x1 , x2 , … , xn ) }
 元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再
找到元组分量，进行谓词判断；
域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变
量组成的元组是否存在或是否满足谓词判断。
 公式的运算符( (与)、  (或)、 (非)、  (全称量词)和(存在量词))是相
同的，只是其中的变量不同
 元组演算和域演算可以等价互换

42.域演算语言QBE
 QBE: Query By Example
 1975年由M. M. Zloof提出，1978年在IBM370上实现
 特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只
需将条件填在表格中即可
 是一种高度非过程化的查询语言
 特别适合于终端用户的使用

43.QBE操作框架由四个部分构成
 关系名区：用于书写欲待查询的关系名
 属性名区：用于显示对应关系名区关系的所有属性名
 操作命令区：用于书写查询操作的命令
 查询条件区：用于书写查询条件

44.QBE的操作命令
 Print 或 P.   ---- 显示输出操作
 Delete或D.   ---- 删除操作
 Insert或I.     ---- 插入操作
 Update或U. ---- 更新操作

45.QBE的查询条件
见PPT

46. 关系代数的并、差、乘积、选择和投影运算可以用QBE来实现

47.关系运算的安全性
“不产生无限关系和无穷验证的运算被称为是安全的”

48.安全约束有限集合DOM
DOM(ψ)是一个有限集合，其中的每个符号要么是中明显出现的符号，要
么是出现在ψ中的某个关系R的某元组的分量。
DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。

49.SQL语言主要由以下9个单词引导的操作语句来构成，但每一种语句都能表
达复杂的操作请求
	 DDL语句引导词：Create(建立),Alter(修改),Drop(撤消)
		 模式的定义和删除，包括定义Database,Table,View,Index,完整性约束
	条件等，也包括定义对象(RowType行对象,Type列对象)
	 DML语句引导词：Insert ,Delete, Update, Select
		 各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery
	建立)输入
		 各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等
		 各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等
	 DCL语句引导词：Grant,Revoke
		 安全性控制：授权和撤消授权

50.SQL语言
见MYSQL

51.三级模式两层映像结构
 对应概念模式的数据在SQL中被称为基本表(Table),而对应外模式的
数据称为视图(View)
。视图不仅包含外模式，而且包含其E-C映像。

52.定义视图
create view view_name [(列名[，列名] …)] 
as 子查询 [with check option]

53.with checkoption指明当对视图进行insert，update，delete时，要检查
进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件
表达式

54.使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用

55.SQL视图更新的可执行性
 如果视图的select目标列包含聚集函数，则不能更新
 如果视图的select子句使用了unique或distinct，则不能更新
 如果视图中包括了groupby子句，则不能更新
 如果视图中包括经算术表达式计算出来的列，则不能更新
 如果视图是由单个表的列构成，但并没有包括主键，则不能更新
 对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选
择、投影操作导出的，并且包含了基本表的主键，则可以更新

56.数据库完整性
数据库完整性(DB Integrity)是指DBMS应保证的DB的一种特性--在任何情
况下的正确性、有效性和一致性
广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等
狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程
序来处理语义完整性问题。

关系模型中有完整性要求
 实体完整性
 参照完整性
 用户自定义完整性

57.完整性约束条件(或称完整性约束规则)的一般形式
Integrity Constraint ::= ( O，P，A，R)
 O：数据集合：约束的对象？
 列、多列(元组)、元组集合
 P：谓词条件：什么样的约束？
 A：触发条件：什么时候检查？
 R：响应动作：不满足时怎么办？

58.按约束对象分类
	 域完整性约束条件	=>施加于某一列上
	 关系完整性约束条件	=>施加于关系/table上

按约束来源分类
	 结构约束	=>来自于模型的约束
	 内容约束	=>来自于用户的约束

按约束状态分类
	静态约束	要求DB在任一时候均应满足的约束
	动态约束	要求DB从一状态变为另一状态时应满足的约束(例如工资只能升，不能降)

59.Col_constr列约束
一种域约束类型，对单一列的值进行约束
{ NOT NULL | //列值非空
[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消
{ UNIQUE //列值是唯一
| PRIMARY KEY //列为主键
| CHECK (search_cond) //列值满足条件,条件只能使用列当前值
| REFERENCES tablename [(colname) ]
[ON DELETE { CASCADE | SET NULL } ] } } 
//引用另一表tablename的列colname的值，如有ON DELETE CASCADE 或ON DELETE SET 
NULL语句，则删除被引用表的某列值v 时，要将本表该列值为v 的记录删除或列值更新为
null；缺省为无操作

60. Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追
加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)

61.未命名的约束是不能撤消

62.断言ASSERTION
一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件
表约束和列约束就是一些特殊的断言
SQL还提供了复杂条件表达的断言。其语法形式为：
CREATE ASSERTION <assertion-name> CHECK <predicate>
当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是
否违反该断言。

63.静态约束：O（列 或者 表）P（需要定义）A（默认更新时检查）R（默认拒绝）
   动态约束：OPAR(全部需要定义)

64.Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),
是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操
作之前执行，或在更新操作之后执行

65.基本语法
CREATE TRIGGER trigger_name BEFORE | AFTER
{ INSERT | DELETE | UPDATE [OF colname {, colname...}] }
ON tablename [REFERENCING corr_name_def {, corr_name_def...} ]
[FOR EACH ROW | FOR EACH STATEMENT]
//对更新操作的每一条结果(前者)，或整个更新操作完成(后者)
[WHEN (search_condition)] //检查条件，如满足执行下述程序
{ statement //单行程序直接书写，多行程序要用下行方式
| BEGIN ATOMIC statement; { statement;...} END }

66.事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}
 当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后
After触发
 操作发生，执行触发器操作需处理两组值：更新前的值和更新后的
值，这两个值由corr_name_def的使用来区分

67. corr_name_def的定义
{ OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为
| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为
| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为
| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为
}
 corr_name_def将在检测条件或后面的动作程序段中被引用处理

68.自主安全性机制
 通常情况下，自主安全性是通过授权机制来实现的。
用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一
定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐
户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户
之间的传播和控制。

69.两种控制示例
 按名控制安全性：存储矩阵
 按内容控制安全性：视图

70.授权命令
GRANT {all PRIVILEGES | privilege {,privilege…}} 
ON [TABLE] tablename | viewname
TO {public | user-id {, user-id…}}
[WITH GRANT OPTION]；

 user-id ，某一个用户账户，由DBA创建的合法账户
 public, 允许所有有效用户使用授予的权利
 privilege是下面的权利
 SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES
 WITH GRANT OPTION选项是允许被授权者传播这些权利

71. 授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本
关系级别和视图级别)
 授权者授予的权利必须是授权者已经拥有的权利

72.收回授权命令
REVOKE {all privilEges | priv {, priv…} } ON tablename | viewname
FROM {public | user {, user…} }; 
示例
revoke select on employee from UserB；

73.强制安全性机制
 强制安全性通过对数据对象进行安全性分级
绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)
 同时对用户也进行上述的安全性分级
 从而强制实现不同级别用户访问不同级别数据的一种机制

74.事务的特性: ACID
原子性Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即
对DB而言，要么全做，要么全不做
一致性Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操
作规则，它是进一步由隔离性来保证的
隔离性Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两
个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行
了T2, 再执行T1。
持久性Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影
响是可恢复的。
换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。



			数据建模
1.E-R模型
	实体，属性，联系，关键字/码

2.实体，客观存在并可相互区分的事物
	一个个实体，简称实例
	一类实体，简称实体
实体用属性来刻画

3.属性，实体某一方面的特性
属性有单一属性和复合属性
	单值属性和多值属性
	可空值的属性和非空值属性
	导出属性：由其他属性计算而来

4.关键字/码，实体中能够用其值唯一区分开每一实例的属性或属性集合

5.联系，指一个实体实例和其他实体实例之间所可能发生的联系

6.角色，实体在联系中的作用被称为实体的角色（role）

7.联系的基数：实体实例之间的联系的数量，即一个实体的实例通过一个联系能与另一实体相关联的实例的数目
最小基数：mincard
最大基数：maxcard
完全参与联系：最小基数为一
不完全参与联系：最小基数为0

8.Chen方法
实体：矩形框
属性：椭圆
多值属性：双线椭圆
导出属性：虚线椭圆
关键字/码：下划线
连接实体和属性：直线
联系：菱形框
连接实体与联系：直线
连接联系和属性：直线
复合关键字：标有相同数字
多组关键字：标有不同数字

1:1联系：箭头直线，由联系指向实体
1:m联系：指向1端为箭头直线，指向多端为无箭头直线
m:n联系：无箭头直线
完全参与联系：双直线
部分参与联系：单直线

1:1, 1:m, m:n的联系也可以如下区分：
1端实体-直线旁标1
多端实体-直线旁标m或n
完全/部分参与联系也可以标注最小基数..最大基数进行区分，最小基数0
的为部分参与联系，最小基数1的为完全参与联系
直线旁标1..1, 0..1, 1..m, 0..m：

9.Crow’s foot方法
实体：矩形框，实体的名称写在横线上面
属性：实体框横线的下面
关键字：属性下加下划线
联系：菱形框表示，也可以将菱形框省略而直接以联系名来替代

10.IDEF1x是将E-R模型扩充语义含义而形成的, 或者说，IDEF1x是E-R图
的细化…
 IDEF1x是一种进行数据建模或数据库设计的工程化的方法

11. 实体(Entity)
 独立标识符实体/独立实体(Identifier-IndependentEntity)--强实体
 从属标识符实体/从属实体(Identifier-dependentEntity)--弱实体

 联系(Relationship)
可标定连接联系(IdentifyingConnectionRelationship)
非标定连接联系(Non-IdentifyingConnectionRelationship)
分类联系(CategorizationRelationship)
非确定联系(Non-SpecificRelationship)

 属性/关键字(Attribute/Key)
属性(Attribute)
主关键字/主码(PrimaryKeys)--主属性
次关键字/候选码(AlternateKeys)
外来关键字/外来码 (ForeignKeys)--外来属性

11.独立实体：一个实体的实例都被唯一的标识而不决定于它与其他实体的联系

从属实体：一个实体的实例的唯一标识需要依赖于该实体与其他实体的联系
从属实体需要从其他实体继承属性作为关键字的一部分
主关键字包含了外来属性的实体为从属实体

独立实体用直角方形框，从属实体用圆角方形框表示
独立实体的主关键字没有外键，从属实体的主关键字含有外键

12.关键字：能唯一确定实体每一个实例的属性或属性组。
关键字，被区分为主关键字和次关键字

 一般实体的主关键字必须遗传为每一个分类实体的主关键字
 存在一个联系，只能有一个外来关键字
 被继承属性只能是主关键字所包含的属性

13.标定联系：子实体的实例都是由它与父实体的联系而确定。父实体的
主关键字是子实体主关键字的一部分

非标定联系：子实体的实例能够被唯一标识而无需依赖与其实体的联
系。父实体的主关键字不是子实体的主关键字。

都为确定联系

关于标定联系和非标定联系的规则：工程化的要求
标定联系用实直线表示，非标定联系用虚直线表示
在子实体一侧有圆圈，联系名标注在直线旁

父实体一个实例可与子实体的0个、1个或多个实例相联系，具体情况由特
定基数而定。在子实体端标注P(1或大于1)/Z(0或1)/n(确定数目)/<省略>
(0,1或大于1）

14.非确定联系：即实体之间的多对多的联系
非确定联系必须分解为若干个一对多的联系来表达

14.分类联系：一个实体实例是由一个一般实体实例及多个分类实体实
例构成的
